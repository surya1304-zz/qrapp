{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar CryptoJS = require(\"crypto-js\");\n\nvar SimpleCrypto =\n/** @class */\nfunction () {\n  function SimpleCrypto(secret) {\n    if (secret === void 0) throw new Error('SimpleCrypto object MUST BE initialised with a SECRET KEY.');\n    this._secret = secret;\n    this._keySize = 256;\n    this._iterations = 100;\n  }\n\n  SimpleCrypto.generateRandom = function (length, expectsWordArray) {\n    if (length === void 0) {\n      length = 128;\n    }\n\n    if (expectsWordArray === void 0) {\n      expectsWordArray = false;\n    }\n\n    var random = CryptoJS.lib.WordArray.random(length / 8);\n    return expectsWordArray ? random : random.toString();\n  };\n\n  SimpleCrypto.prototype.encrypt = function (data) {\n    if (data == void 0) throw new Error('No data was attached to be encrypted. Encryption halted.');\n    var string = typeof data == \"object\" ? JSON.stringify(data) : typeof data == \"string\" || typeof data == \"number\" || typeof data == 'boolean' ? data.toString() : null;\n    if (null === string) throw new Error('Only object, string, number and boolean data types that can be encrypted.');\n    var salt = SimpleCrypto.generateRandom(128, true);\n    var key = CryptoJS.PBKDF2(this._secret, salt, {\n      keySize: this._keySize / 32,\n      iterations: this._iterations\n    });\n    var initialVector = SimpleCrypto.generateRandom(128, true);\n    var encrypted = CryptoJS.AES.encrypt(string, key, {\n      iv: initialVector,\n      padding: CryptoJS.pad.Pkcs7,\n      mode: CryptoJS.mode.CBC\n    });\n    var ciphered = salt.toString() + initialVector.toString() + encrypted.toString();\n    return ciphered;\n  };\n\n  SimpleCrypto.prototype.decrypt = function (ciphered, expectsObject, enc) {\n    if (expectsObject === void 0) {\n      expectsObject = false;\n    }\n\n    if (enc === void 0) {\n      enc = CryptoJS.enc.Utf8;\n    }\n\n    if (ciphered == void 0) throw new Error('No encrypted string was attached to be decrypted. Decryption halted.');\n    var salt = CryptoJS.enc.Hex.parse(ciphered.substr(0, 32));\n    var initialVector = CryptoJS.enc.Hex.parse(ciphered.substr(32, 32));\n    var encrypted = ciphered.substring(64);\n    var key = CryptoJS.PBKDF2(this._secret, salt, {\n      keySize: this._keySize / 32,\n      iterations: this._iterations\n    });\n    var decrypted = CryptoJS.AES.decrypt(encrypted, key, {\n      iv: initialVector,\n      padding: CryptoJS.pad.Pkcs7,\n      mode: CryptoJS.mode.CBC\n    });\n    var data = expectsObject ? JSON.parse(decrypted.toString(enc)) : decrypted.toString(enc);\n    return data;\n  };\n\n  SimpleCrypto.prototype.encryptObject = function (object) {\n    return this.encrypt(object);\n  };\n\n  SimpleCrypto.prototype.decryptObject = function (string) {\n    var decrypted = this.decrypt(string, true);\n    var object = typeof decrypted == 'object' ? decrypted : JSON.parse(decrypted);\n    return object;\n  };\n\n  SimpleCrypto.prototype.setSecret = function (secret) {\n    this._secret = secret;\n  };\n\n  return SimpleCrypto;\n}();\n\nexports.default = SimpleCrypto;","map":null,"metadata":{},"sourceType":"script"}